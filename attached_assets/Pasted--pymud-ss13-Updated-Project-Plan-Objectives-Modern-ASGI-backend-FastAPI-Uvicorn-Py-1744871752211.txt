# pymudâ€‘ss13 Updated Project Plan

## ğŸ¯ Objectives
- **Modern ASGI backend**: FastAPI + Uvicorn, Pydantic settings, clean lifecycle hooks  
- **Patternâ€‘based DSL command parser** with YAML specs, user aliases, synonyms & fuzzy matching (via RapidFuzz)  
- **Componentâ€‘based object model** for rooms, items, machines, players  
- **Eventâ€‘driven â€œsystemsâ€** architecture (atmospherics, power grid, jobs, AI)  
- **Dynamic inâ€‘world scripting** sandbox (RestrictedPython or Lua) for LambdaMOOâ€‘style verbs  
- **Persistent state** (YAML/JSON + script attachments) with autosave/snapshots  
- **WebSocketâ€‘powered web client**: command I/O, grid/map renderer, status overlays  
- **Developer DX**: interactive dev shell, hotâ€‘reload plugins, Pydanticâ€‘validated JSON protocol  
- **Quality & CI/CD**: unit tests, type checks, GitHub Actions, containerized deploy  

---

## ğŸ›  Phases & Tasks

### PhaseÂ 1 â€“ ASGI Foundation
- [ ] **Settings & DI**  
  - Define `Settings` via PydanticÂ `BaseSettings` (`.env` support)  
  - Inject `MudEngine`, `World`, `ConnectionManager` via FastAPI dependencies  
- [ ] **Connection Manager**  
  - Implement perâ€‘WebSocket `asyncio.Queue` send loops  
  - Handle `connect` / `disconnect` / `broadcast` cleanly  
- [ ] **WebSocket Endpoint**  
  - Mount `/ws` in FastAPI  
  - Login handshake â†’ `engine.add_player()` â†’ session mapping  
  - Loop: `await ws.receive_text()` â†’ `await engine.process_message()` â†’ enqueue response  

### PhaseÂ 2 â€“ DSLâ€‘Style Command Parser
- [ ] **YAML Command Specs** (`commands.yaml`)  
  - Define `name`, `patterns` (`"get {item}"`, `"get {item} from {container}"`), `help` text  
- [ ] **Compile to Regex**  
  - At startup, build `CommandSpec` objects with `re.compile()` patterns  
- [ ] **Synonyms & Aliases**  
  - Load global synonyms (`{"n":"move north",â€¦}`) + perâ€‘player aliases from profile  
- [ ] **Fuzzy Matching**  
  - Integrate RapidFuzz for entity resolution (`rapidfuzz.process.extractOne`)  
- [ ] **Dispatch Loop**  
  - On input: expand alias â†’ match specs â†’ fuzzyâ€‘resolve captures â†’ call handler â†’ fallback suggestions  

### PhaseÂ 3 â€“ Component System
- [ ] **`GameObject` dataclass**  
  - Fields: `id`, `name`, `description`, `components: dict[str, Component]`  
  - Methods: `add_component()`, `get_component()`, event hook dispatch  
- [ ] **Core Components** (`components/`)  
  - Door (open/close/lock), AccessControl, Container, Inventory, Machine, Hazard  
- [ ] **YAML â†’ Components**  
  - Extend loader in `world.py` to instantiate component classes with state  

### PhaseÂ 4 â€“ Eventâ€‘Driven Systems
- [ ] **`events.py`**  
  - `subscribe(event_name, fn)`, `publish(event_name, **ctx)`  
- [ ] **Systems Skeletons** (`systems/`)  
  - **atmos.py**: zones, gas mixes, vents â†’ `publish("pressure_change")`  
  - **power.py**: grids, breakers â†’ autoâ€‘lock doors on power loss  
  - **jobs.py**: crew roles, loadouts, shift assignments  
  - **ai.py**: NPC behavior loops, task scheduling  

### PhaseÂ 5 â€“ Dynamic Inâ€‘World Scripting
- [ ] **Sandbox Integration**  
  - Pick RestrictedPython (or Lua via `lupa`) for safe exec  
  - `script_manager.py`: `compile_restricted()`, `exec()` in limited globals  
- [ ] **Inâ€‘Game Verb API**  
  - `@register("addverb")` command to attach `command_<verb>` functions to objects  
  - Persist code snippets in world state  
- [ ] **Script Persistence**  
  - Extend `persistence.py` to dump & reload attached code per object  

### PhaseÂ 6 â€“ SS13â€‘Style Systems
- [ ] **Atmospherics**: gas mixes, pressure propagation, leak/hazard detection  
- [ ] **Power Grid**: grid nodes, power flow, manual overrides, cascading failures  
- [ ] **Jobs & AI**: roleâ€‘based equipment, NPC patrols, task queues  
- [ ] **Hazards & Events**: radiation leaks, quarantine protocols, fire propagation  

### PhaseÂ 7 â€“ Persistence Enhancements
- [ ] **State Serialization**  
  - Serialize `GameObject` fields + component state + scripts as YAML/JSON  
- [ ] **Autosave & Snapshots**  
  - Background task to save every X minutes via `aiofiles` or `asyncio.to_thread()`  
- [ ] **Graceful Shutdown**  
  - FastAPI `shutdown` hook to flush state  

### PhaseÂ 8 â€“ Web Client & UI
- [ ] **Command I/O Panel**  
  - WebSocket connection, `<textarea>` or React component for chat log  
  - Pydanticâ€‘validated JSON messages for rich updates  
- [ ] **Gridâ€‘Map Renderer**  
  - CSS Grid or Canvas overlay to draw station layout from room graph  
  - Clickable cells to inspect room details  
- [ ] **Status Overlays**  
  - Door lock icons, atmos warning badges, power status indicators  
- [ ] **Autocomplete & Help**  
  - HTTP endpoints `/autocomplete`, `/help/{cmd}` for client suggestions  

### PhaseÂ 9 â€“ Developer Tooling & DX
- [ ] **Interactive Dev Shell**  
  - `make shell` â†’ IPython with `engine`, `world`, `GameObject` instances  
- [ ] **Hotâ€‘Reload Watcher**  
  - Watch `plugins/` & `data/` via `watchgod`; reload only changed modules  
- [ ] **Code Generators**  
  - `mud-cli generate component Door --fields locked:bool`  

### PhaseÂ 10 â€“ Testing & CI/CD
- [ ] **Unit Tests**  
  - `engine.process_message()`, `CommandSpec.match()`, component behavior, event bus, scripting  
- [ ] **Type Checking**  
  - Mypy on `*.py`  
- [ ] **GitHub Actions**  
  - Lint (flake8/black), test suite, build Docker image, security scan  
- [ ] **Containerization**  
  - Dockerfile multiâ€‘stage build, publish image to registry  

---

## ğŸš€ Milestones
- **M1**: ASGI server + DSL parser + basic world load/save  
- **M2**: Component instantiation + event bus + core SS13 door & access  
- **M3**: Scripting sandbox + inâ€‘world verb support + script persistence  
- **M4**: Atmos & power systems + web client grid renderer  
- **M5**: Full CI/CD pipeline + dev shell + docs + sample scenario  

> _Save this as `docs/roadmap.md` in your repo. Check off tasks as you progress and tweak the plan as your vision evolves!_  